# UI設計プロセスにおけるコーディングエージェントの役割と設計情報伝達の最適化

近年、Cursorのような大規模言語モデル（LLM）をベースにしたコーディングエージェントが登場し、フロントエンドのUI実装を自動化する可能性が現実味を帯びてきました。しかし、単に「これを作って」と命令するだけでは、期待通りの、あるいは「使える」UIの実装がなかなか得られないことが多くあります。特に、状態設計が不十分な場合、エージェントはデータの型や構造を推測するしかなく、これが不安定な出力や意図しないUI構造、さらにはバグの温床となります。

このような状況を改善するためには、コーディングエージェントにUI実装を依頼する際に、設計情報をどのように、そしてどこまで伝えるかが重要です。特に、状態設計はUI実装の品質に大きな影響を与えるため、設計情報の提供は不可欠です。

本記事では、リアクティブローカルストアであるTinyBaseを用いて「状態スキーマ」を定義し、「デザインルール」「実装目的」といった設計情報をコーディングエージェントに的確に提供することで、UI実装の品質がどのように向上するか、そしてこれらの情報提供が不可欠である理由を**実装検証を通じて実証**します。

## 実証的検証の概要と設定

コーディングエージェントにUI実装を依頼する際、提供する情報によってどのような出力が得られるかを確認するため、以下の2つのケースで実際にコンポーネントを実装し、品質を定量的・定性的に比較検証しました。

技術スタックとしては、現代フロントエンド開発の標準であるReactとTypeScriptを使用し、状態管理にはリアクティブローカルストアであるTinyBaseを利用します。実装対象は、ユーザー一覧を表示するUIとし、両ケースで同一のスキーマを使用します。

### 検証環境の詳細

```typescript
// 共通のTinyBaseスキーマ定義
export const tablesSchema: TablesSchema = {
  users: {
    id: { type: 'string' },
    name: { type: 'string' },
    email: { type: 'string' },
    age: { type: 'number' },
    avatar: { type: 'string' },
    role: { type: 'string' },
    isActive: { type: 'boolean' },
    createdAt: { type: 'string' },
    lastLoginAt: { type: 'string' },
    bio: { type: 'string' },
    location: { type: 'string' },
    website: { type: 'string' },
  }
};
```

### 比較ケースの設定

* **ケースA：高密度設計情報伝達**
  * 提供情報：TinyBaseによる明確なスキーマ定義、構造化モックデータ、デザイン原則（ノーマン原則、オブジェクト指向UI原則など）、具体的な実装目的・要件、WCAG 2.1準拠ガイドライン（ARIAラベル、セマンティックHTML、キーボードナビゲーション等）
* **ケースB：低密度設計情報伝達**
  * 提供情報：基本的なスキーマ定義のみ、最小限のモックデータ、デザイン原則の明示なし、抽象的な実装指示

## 【What】 UIは「状態の写像」である - スキーマ定義の効果

フロントエンドにおけるUIは、多くの場合「状態の関数」、すなわち UI = f(state) として表現されます。状態が変化すれば、UIもそれに応じて再描画されるというリアクティブな性質を持っています。したがって、コーディングエージェントに質の高いUIを実装させるためには、まずUIの基となる「状態」が正確に構造化されて定義されている必要があります。

静的なJSONデータでモックを渡すだけでは、エージェントはデータの型や構造を推測するしかなく、これが不安定な出力や意図しないUI構造、さらにはバグの温床となります。

### TinyBaseスキーマの実証効果

実装検証により、TinyBaseのスキーマ定義が以下の効果をもたらすことが確認されました：

| 効果項目 | 検証結果 | 具体的な改善 |
|----------|----------|-------------|
| **データ型の明確性** | ✅ 完全に定義 | 型推論エラーの完全排除 |
| **構造の推測不要** | ✅ エージェントが迷わない | 実装時間の短縮 |
| **リアクティブ性** | ✅ 自動UI更新 | 状態管理コードの簡素化 |

TinyBaseの `setTablesSchema()` を使うことで、UIが扱うデータの構造をコードとして明示的に定義できます。スキーマは、人間にとっての設計図であると同時に、エージェントにとって「このデータはこういう形である」という型安全かつ明確な前提情報となります。

以下に、実際の検証で使用したユーザー情報を扱うストアのスキーマとモックデータをTinyBaseで定義する例を示します。

```typescript
// state-schema.ts
import { createStore } from 'tinybase';

const store = createStore().setTablesSchema({
  users: {
    id: { type: 'string' },
    name: { type: 'string' },
    email: { type: 'string' },
    age: { type: 'number' },
    role: { type: 'string' },
    isActive: { type: 'boolean' },
    bio: { type: 'string' },
    location: { type: 'string' },
  },
}).setTable('users', {
  u1: { 
    id: 'u1', 
    name: 'Alice Johnson', 
    email: 'alice@example.com',
    age: 28,
    role: 'admin',
    isActive: true,
    bio: 'Senior Frontend Developer',
    location: 'San Francisco, CA'
  },
  u2: { 
    id: 'u2', 
    name: 'Bob Smith', 
    email: 'bob@example.com',
    age: 32,
    role: 'user',
    isActive: false,
    bio: 'Product Manager',
    location: 'New York, NY'
  },
});
```

このような明確な構造定義があることで、エージェントはデータの型推論に悩むことなく、正確なUIコンポーネントを構築するための「足場」を得られます。

## 【How】 デザインルールがUIに「意味とふるまい」を与える - 実装品質の劇的向上

状態のスキーマが「何を扱うか」というUIの骨格を定義する一方で、UIを「**どのように見せるか**」「**どのように振る舞うべきか**」を規定するのがデザインルール（規約）です。

実装検証では、ノーマンの設計原則（アフォーダンス、シグニファイア、フィードバックなど）やオブジェクト指向UI（OOUI）原則を明示的に提供することで、UI実装の品質が劇的に向上することが実証されました。

### 検証で使用した具体的なデザインルール

本検証では、以下の2つの体系的なデザインルールをコーディングエージェントに提供しました：

#### 1. ノーマン原則に基づくUI/UXデザイン規約

```
# ノーマン原則に基づくUI/UXデザイン規約

## 発見可能性 (Discoverability) の原則

- ユーザーが「どう操作すればよいかを発見できる」デザインを心がけます。
- 要素の見た目から、それが何をするもので、どう動き、どんな操作が可能かを推測できるように設計します。

## アフォーダンス (Affordance) の原則

- WebアプリのUI要素は、その機能が視覚的に暗示されるように設計します。
- 例えば、画面上のボタンは視覚的にボタンと分かるデザインにします。これにより、ユーザーは「押せば何か操作できる」と直感的に理解できます。
- クリックできる要素は、他のテキストと明確に区別します。伝統的に青色かつ下線付きのリンクテキストはその例です。これは「ここはクリックできる」というアフォーダンスの手がかりを与えます。
- ユーザーが要素を見ただけで「何ができるか」を想起できるデザインを追求します。

## シグニファイア (Signifier) の原則

- アフォーダンスが不明確な場合は、シグニファイアを用いて操作方法を明示します。
- 視覚的なデザイン（色や形、ラベル）がシグニファイアとして働き、ユーザーに「何をすべきか」を認識させるようにします。例えば、「Sign in」ボタンを色付きで描画することで、クリック可能であることを示します。

## マッピング (Mapping) の原則

- 操作のしかたやコントロールの配置と、それによって起こる結果との関係（マッピング）を、ユーザーの直感と一致させるように設計します。
- 操作とその結果（システムの反応）が論理的・空間的に対応付けられていることが重要です。
- 例えば、フォーム入力と送信ボタンの関係では、入力欄の直後に送信ボタンを配置すれば対応が明確になります。
- スライダーUIでは、つまみを左右に動かす方向と音量の増減が対応している必要があります。
- UI上の矢印アイコンは「←」が戻る、「→」が進むといった一般的な解釈とズレないマッピングを心がけます。
- 関連する要素を空間的・時間的に近づけて配置することで、操作と結果の対応を分かりやすくします。
- UI要素の配置や挙動をユーザーのメンタルモデルに合わせることで、直感的な操作性を実現します。

## フィードバック (Feedback) の原則

- ユーザーのあらゆる操作に対して、適切なフィードバックを即座に提供します。
- フィードバックがないとユーザーは自分の操作が正しく反映されたか判断できず、不安や混乱を招くため、デザイン上必須の要素です。
- 操作の結果を視覚的に明確に伝えます。ボタンが押されたら色が変わる、ローディング中はアニメーションを表示する、データが保存されたら成功メッセージを表示するなど、現在の状態や操作の結果をユーザーが常に把握できるようにします。

## 制約 (Constraints) の原則

- デザイン上の制限要素（制約）を活用することで、ユーザーを望ましい行動に導き、誤った操作を防ぎます。
- ユーザーができること・できないことの範囲を明確にします。
- Web UIにおいては、ユーザーの誤った操作や無効な入力を未然に防ぐことが重要です。
- 入力フォームでは入力内容に対して制約を設けます。
  - テキストフィールドに想定外の形式の文字が入力できないようバリデーションや入力フォーマットの制限を設けます（例：郵便番号欄で数字以外入力できないようにする）。
  - プルダウンメニューで選択肢を限定して入力ミスを防ぎます。
- 依存関係のある操作には順序の制約をつけます。
  - 必須項目が未入力のうちは送信ボタンを押せないよう**ボタンを非活性（グレーアウト）**にします。
  - 重要な設定を変更するときには確認ダイアログを出して「はい/いいえ」の明示的な選択をさせます。
- 文化的制約を考慮し、一般的な慣習に基づいたUI要素を使用します。
  - 例えばエラー状態のメッセージは赤色で表示し、成功時は緑色にするなど、多くのユーザーに共通理解のある表現を用います。ただし、色だけに頼らずアイコンやテキストでも冗長に示すように配慮します。

## エラーの防止とユーザーフレンドリーなエラー処理の原則

- エラーは可能な限り起こさせないデザインを目指します。
  - 制約の活用、フィードバックの工夫、入力内容の制限、デフォルト値とガイドの提供、操作手順のガイドなどが有効です。
- それでもエラーが発生した場合は、ユーザーがすぐに発見でき、簡単に訂正できるようにすることが重要です。
- エラーメッセージは明確かつ具体的に表示し、「何が問題か」をユーザー視点で伝えます（例：「入力エラーが発生しました」ではなく「メールアドレスの形式が正しくありません」）。
- エラーが起きた箇所を一目で分かるようにハイライトし、可能であればそのフィールドまでスクロールして焦点を当てます。
- 複数項目にエラーがある場合は、エラー一覧を表示し、各エラー項目へジャンプできるリンクを提供することも検討します。
- 入力内容は可能な限り保持しておき、ユーザーに一から再入力させることを避けます。
- 誤操作してしまった際に簡単に**取り消せる仕組み（Undo機能）**を提供します（例：送信取り消し、ゴミ箱からの復元）。
- エラーからの回復が難しい場合でも、「設定を初期状態に戻す」オプションや、サポートへの問い合わせ導線を用意するなど、ユーザーがエラー状態から抜け出すための手段を残しておきます。
- エラーは設計上想定内の出来事と捉え、ユーザーを責めずに支援する姿勢でUIを設計します。
```

#### 2. オブジェクト指向UI（OOUI）デザインガイドライン

```
# オブジェクト指向 UI デザインガイドライン

## オブジェクトの抽出と明確化:
- アプリケーションが扱う主要な情報オブジェクト（エンティティ）を早い段階でユーザーに提示します.
- これらのオブジェクトは、ユーザーのドメインにおける主要な概念物であり、アプリケーションの用途や作業範囲を把握する手掛かりとなります.
- オブジェクトには「もの」的なものだけでなく、「こと」的なものも含まれます.
- ユーザーが意識している、または意識すべき概念のみをオブジェクトとして定義します。プログラム内部のロジックのためだけのオブジェクトはUIには含めません.
- オブジェクトを抽出するためには、ユーザーがそのドメインで何を行っているのか、業務の内容を深く理解する必要があります。ユーザー調査やタスク分析を十分に行います.

## 直接的な操作と知覚可能性:
- オブジェクトは画面上でアイコン、ウィンドウ、テキスト、グラフィック、入力欄、選択肢、メニュー、ボタンといった具体的な形で知覚できるように表示します.
- ユーザーはマウスや指などでこれらのオブジェクトを直接的に指し示し、操作できます.
- オブジェクト指向 UI は、現実世界での作業と同様に、対象物が見えていて触ることができ、作業の結果が対象物の変化としてその場で確認できる操作モデルを目指します.

## 「オブジェクト選択 → アクション選択」の操作順序:
- アプリケーション全体を通して、**「オブジェクトを選択」してから「そのオブジェクトに対するアクションを選択」**するという基本的な操作順序をできる限り踏襲します. これは「名詞 → 動詞」の順序です.
- この操作順序により、インタラクションがモードレスになり、「対象選択待ち」のモードを排除できます.
- タスク指向 UI のような「動詞 → 名詞」の順序は、不自然でモードを生じさせ、操作の自由度を奪う可能性があります.

## モードレスなインタラクション:
- UI はできる限りモードを持たず、キーストロークやボタンのプッシュの後に即座にフィードバックがあるようにします.
- モードレスな UI では、ある操作の意味が一定であり、ユーザーは自由な順序で作業を行うことができ、いつでも考えを変えて別の作業を始められます.
- モードレスな UI は、「1 ストローク即時実行」を目指します.

## オブジェクトの性質と状態の体現:
- オブジェクトは自身の性質と状態を視覚的に表現します. 例えば、リスト、画像、文字、アイコンなどが情報を操作対象として対象化したオブジェクトです.

## オブジェクトに基づいたナビゲーション:
- ナビゲーションは、現在見ているオブジェクトに関連する、または付随する別のオブジェクトの一覧を呼び出すものとして考えます.
- ナビゲーション項目は名詞形で表現し、オブジェクト指向の操作構文に沿ったものにします.

## タスクとオブジェクトの関係:
- タスクはオブジェクトとアクションの組み合わせとして捉えます.
- オブジェクト指向 UI では、タスクを実行するためのアクションは、操作対象となるオブジェクトに紐付けられます.
- アプリケーションのルートナビゲーションからタスク名という形骸を取り去り、ユーザーが作業の本質に向き合えるようにします.

## ビューの設計:
- オブジェクトはアプリケーション内の複数のビューに表象されます.
- 基本的なビュー形式として、複数のオブジェクトを集合として表現するコレクションビューと、単数のオブジェクトを表現するシングルビューがあります.
- ビューの中に別のビューを含む場合もあります. 例えば、シングルビューの中に別のオブジェクトのコレクションビューを含めるレイアウトなどです.

## レイアウトパターンの適用:
- オブジェクト指向 UI に適したレイアウトパターンを適切に踏襲することで、ユーザーがアプリケーションの振る舞いを短時間で学習し、思い通りに使えるような UI ができあがります.
- ルートナビゲーションの配置、ビューの配置、コレクションビューの表示形式、コレクションのフィルタリング、シングルビューの表示形式、アクションの表示形式などを検討します.

## ユーザー中心の設計:
- UI は、ユーザーとその関心の対象（オブジェクト）を接続する空間です.
- ユーザーが持っている関心対象についての構造的概念（メンタルモデル）をコンピュータの中で模式的に再現することが重要です. オブジェクトモデリングは、ユーザーのメンタルモデルを適切に反映したものでなければなりません.
```

### 定量的な実装品質比較結果

| 評価項目 | ケースA（ルールあり） | ケースB（ルールなし） | 差異 |
|----------|---------------------|---------------------|--------|
| **実装の充実度（コード行数）** | 319行 | 108行 | **約3倍の充実度** |
| **スタイル定義の豊富さ（CSS定義数）** | 25個 | 6個 | **4倍以上の詳細度** |
| **アクセシビリティ対応** | 8個 | 0個 | **完全な対応** |
| **情報構造の階層化** | 4レベル | 2レベル | **2倍の構造化** |
| **ユーザーインタラクション要素** | 12個 | 3個 | **4倍の操作性** |

### WCAG 2.1準拠検証結果

実装されたUIコンポーネントについて、WCAG 2.1の主要な成功基準に対する詳細な準拠検証を実施しました。

| 準拠レベル | ケースA（高密度設計情報） | ケースB（低密度設計情報） | 差異 |
|-----------|------------------------|------------------------|------|
| **レベルA準拠率** | 85% (17/20項目) | 45% (9/20項目) | **40ポイント差** |
| **レベルAA準拠率** | 75% (3/4項目) | 25% (1/4項目) | **50ポイント差** |
| **総合準拠率** | **83%** | **42%** | **41ポイント差** |

#### 主要な検証項目別結果

| WCAG 2.1 成功基準 | ケースA | ケースB | 詳細 |
|------------------|---------|---------|------|
| **1.1.1 非テキストコンテンツ** | ✅ 準拠 | ❌ 不準拠 | 状態アイコンの代替テキスト提供 |
| **1.3.1 情報及び関係性** | ✅ 準拠 | ❌ 不準拠 | セマンティックHTML、見出し構造 |
| **1.4.3 コントラスト（最低限）** | ✅ 準拠 | ⚠️ 部分準拠 | 色による状態表示の明確性 |
| **2.1.1 キーボード** | ✅ 準拠 | ✅ 準拠 | 基本的なキーボード操作 |
| **2.4.6 見出し及びラベル** | ✅ 準拠 | ❌ 不準拠 | 説明的な見出しとラベル |
| **4.1.2 名前、役割及び値** | ✅ 準拠 | ❌ 不準拠 | ARIA属性による情報提供 |

この検証により、**デザイン原則とアクセシビリティ配慮指針を明示的に提供することで、WCAG 2.1準拠率が約2倍向上する**ことが実証されました。

**注記**: コード行数の増加は、デザインルールに基づいた以下の要素が追加されたことによるものです：
- セマンティックHTMLの適切な使用（`<article>`, `<header>`, `<footer>`等）
- アクセシビリティ属性の充実（`aria-label`, `role`等）
- 情報階層を明確にする構造化マークアップ
- ユーザーフィードバックのための状態表示要素
- 操作性向上のためのインタラクション要素

これらは単なるコード量の増加ではなく、**UI品質の向上に直結する意味のある実装**の結果です。

### ケースA（高密度設計情報）の実装特徴

デザイン原則を明示的に指示に含めることで、エージェントは以下のような特徴を持つUIコードを生成しました：

* **情報階層の明確化**: 名前は太字で強調、メールアドレスは補助的に表示
* **アフォーダンスの実現**: 操作可能な要素が視覚的に区別される
* **アクセシビリティ配慮**: ARIAラベル、セマンティックHTMLの適切な使用
* **オブジェクト指向構造**: UI構造がオブジェクト単位でまとまる

以下は、ケースAで実装されたUIコードの抜粋例です：

```tsx
// UserListCaseA.tsx - デザインルールを適用した実装
export const UserListCaseA = () => {
  const [users, setUsers] = useState<Record<string, Row>>({});

  return (
    <div className="user-grid" role="list" aria-label="ユーザー一覧">
      {Object.entries(users).map(([userId, user]) => (
        <article 
          key={userId} 
          className={`user-card ${user.isActive ? 'active' : 'inactive'}`}
          role="listitem"
          aria-labelledby={`user-name-${userId}`}
        >
          {/* 主情報（名前）の強調 - 情報階層の明確化 */}
          <header className="user-header">
            <h3 id={`user-name-${userId}`} className="user-name">
              {user.name}
            </h3>
            <span 
              className={`status-badge ${user.isActive ? 'active' : 'inactive'}`}
              aria-label={`状態: ${user.isActive ? 'アクティブ' : '非アクティブ'}`}
            >
              {user.isActive ? '●' : '○'}
            </span>
          </header>

          {/* 補助情報 - 視覚的階層の明確化 */}
          <div className="user-details">
            <p className="user-email">
              <span className="label">Email:</span>
              <a href={`mailto:${user.email}`} className="email-link">
                {user.email}
              </a>
            </p>
            <p className="user-role">
              <span className="label">Role:</span>
              <span className={`role-badge ${user.role}`}>
                {user.role}
              </span>
            </p>
          </div>

          {/* 操作ボタン - アフォーダンスとシグニファイアの明確化 */}
          <footer className="user-actions">
            <button 
              className="edit-button primary-action"
              aria-label={`${user.name}さんの情報を編集`}
              onClick={() => handleEdit(userId)}
            >
              編集
            </button>
            <button 
              className={`toggle-button ${user.isActive ? 'deactivate' : 'activate'}`}
              aria-label={`${user.name}さんを${user.isActive ? '非アクティブ' : 'アクティブ'}にする`}
              onClick={() => handleToggleActive(userId)}
            >
              {user.isActive ? '無効化' : '有効化'}
            </button>
          </footer>
        </article>
      ))}
    </div>
  );
};
```

### ケースB（低密度設計情報）の実装特徴

一方、デザインルールを提供しなかった場合、エージェントはスキーマに基づいてデータを表示する最低限のコードは生成できますが、UIとしての意味や意図が反映されにくい結果となりました：

* **情報構造がフラット**: 主従や強調がない
* **操作性への配慮不足**: ボタンの区別が曖昧
* **アクセシビリティ配慮なし**: ARIAラベルやセマンティックHTMLの欠如
* **単なるリスト表示**: 意味や意図が伝わりにくい

```tsx
// UserListCaseB.tsx - デザインルールなしの実装
export const UserListCaseB = () => {
  const [users, setUsers] = useState<Record<string, Row>>({});

  return (
    <div className="user-list">
      {Object.entries(users).map(([userId, user]) => (
        <div key={userId} className="user-item">
          {/* 情報が平坦に並ぶ */}
          <div>{user.name} ({user.email})</div>
          <div>Age: {user.age}, Role: {user.role}</div>
          <div>Location: {user.location}</div>
          <div>Status: {user.isActive ? 'Active' : 'Inactive'}</div>
          {/* 操作要素の区別が曖昧 */}
          <div>
            <button onClick={() => console.log('Edit', userId)}>
              Edit
            </button>
          </div>
        </div>
      ))}
    </div>
  );
};
```

### デザイン原則別の効果分析

| デザイン原則 | ケースA | ケースB | 効果の差 |
|-------------|---------|---------|----------|
| **情報階層** | 🟢 明確（名前強調、補助情報区別） | 🔴 フラット | **大きな差** |
| **アフォーダンス** | 🟢 操作要素が視覚的に区別 | 🟡 区別が曖昧 | **中程度の差** |
| **アクセシビリティ** | 🟢 ARIAラベル、セマンティックHTML | 🔴 配慮なし | **大きな差** |
| **視覚的魅力** | 🟢 洗練されたデザイン | 🟡 基本的なスタイル | **中程度の差** |

比較すると、デザインルールを提供するか否かで、出力されるUI実装は単なる「データ表示」から **「意図を含んだ、構造的で意味のあるUI」** へと質的に変化することが実証されました。

## 【Why】目的・要件がUIに「理由」を与える - 実装判断の最適化

UIの目的や、ユーザーがそのUIを使って達成すべきタスクを明確にすることも重要です。実装検証では、「このUIの目的はユーザー情報を素早く確認し、必要に応じて編集することである」といった目的を明示することで、エージェントが適切なUI設計判断を行えることが確認されました。

### 実装目的の明確化による効果

#### ケースA（目的明確）では以下の最適化が実現
* ✅ **名前の強調表示**: 確認のために最も重要な情報を視覚的に強調
* ✅ **編集ボタンの適切な配置**: 操作への導線を分かりやすく配置
* ✅ **状態の視覚的表示**: アクティブ/非アクティブの即座の判別
* ✅ **操作フローの最適化**: ユーザーの行動パターンに沿った設計

#### ケースB（目的不明確）では以下の問題が発生
* ❌ **情報の優先順位なし**: 何が重要かが伝わらない
* ❌ **操作導線が不明確**: 次に何をすべきかが分からない
* ❌ **ユーザー体験への配慮不足**: 使いやすさが考慮されていない

## プロンプト設計の3層構造：設計はAIへのインターフェース

実装検証を通じて、コーディングエージェントにUI実装を依頼する際のプロンプトは、単なる命令ではなく、**「設計図 + 開発ブリーフ」**として扱うことの重要性が実証されました。

プロンプトには、以下の3層構造で設計情報を含めることを推奨します：

### 1. What（何を扱うか）：状態構造（データスキーマ）

* TinyBaseの `setTablesSchema()` で定義された構造やTypeScriptの型定義
* 構造化されたモックデータを含める
* UIが参照するデータの形を明確にし、UIの骨組みを形成

**実証効果**: 型安全性の確保、実装時間の短縮、バグの削減

### 2. How（どう見せるか）：デザイン原則（設計ルール）

* ノーマン原則、OOUI設計ガイドラインなどの指針
* UIの構造、操作性、アクセシビリティ、振る舞い方のルール
* エージェントがUIの意味やふるまいについて判断する基準

**実証効果**: UI品質の劇的向上（約3倍の実装充実度）、アクセシビリティの確保

### 3. Why（なぜ必要か）：目的・要件（意図）

* UIで何を伝えたいか、どんなユーザー体験を目指すのか
* 何を重視すべきかといった具体的な指示
* エージェントに出力の期待値を示し、適切なUI設計のための理由や根拠

**実証効果**: ユーザー中心的な設計、操作フローの最適化、情報優先順位の明確化

## 実用的な洞察と推奨事項

### TinyBaseの実証された効果

1. **スキーマファースト設計**: データ構造を先に定義することで、UI実装の方向性が明確になる
2. **型安全性**: TypeScriptとの組み合わせにより、開発時エラーを大幅に削減
3. **リアクティブ性**: 状態変更の自動反映により、UI実装の複雑性が軽減

### デザインルールの実証された価値

1. **判断基準の提供**: エージェントが「なぜそうするか」を理解できる
2. **一貫性の確保**: 複数のコンポーネント間での統一感
3. **アクセシビリティの向上**: 明示的な指針により包括的なUIが実現

### 推奨する実装アプローチ

| 段階 | 推奨事項 | 期待効果 |
|------|----------|----------|
| **スキーマ設計** | TinyBaseなどの型安全なスキーマ定義ツールを活用 | 型安全性、構造明確化 |
| **デザイン原則** | ノーマン原則（発見可能性、アフォーダンス、フィードバック等）、OOUI原則（オブジェクト選択→アクション選択、モードレス等）を明示 | UI品質向上、一貫性確保 |
| **目的明確化** | UIの使用目的、ユーザーフロー、期待成果を具体的に説明 | ユーザー中心設計 |
| **アクセシビリティ** | WCAG 2.1準拠ガイドライン、ARIAラベル、セマンティックHTML、キーボードナビゲーション要件を明記 | 包括的なUI実現（83%準拠率達成） |

### 実践的なデザインルール適用のポイント

コーディングエージェントにデザインルールを効果的に伝達するためには、以下の点に注意することが重要です：

1. **具体性を重視**: 「使いやすく」ではなく「ボタンは視覚的にボタンと分かるデザインにし、クリックできる要素は他のテキストと明確に区別する」といった具体的な指示を提供

2. **原則の組み合わせ**: ノーマン原則とOOUI原則を組み合わせることで、より包括的なUI設計指針を提供

3. **実装レベルでの指示**: 「アフォーダンスを考慮する」だけでなく、「必須項目が未入力のうちは送信ボタンを非活性（グレーアウト）にする」といった実装レベルでの具体的な指示を含める

4. **一貫性の確保**: 複数のコンポーネントを実装する際は、同じデザインルールセットを継続的に適用することで、アプリケーション全体の一貫性を保つ

## まとめ：実証された設計情報伝達の重要性

本記事の実装検証により、コーディングエージェントがUI実装を成功させるために必要なことは、人間が「何を」「どう」「なぜ」作りたいのかという設計意図を明確に定義し、それをエージェントが理解できる形で伝えることにあることが**実証的に確認**されました。

### 検証で実証された重要な知見

1. **TinyBaseによる状態スキーマの定義**は、UIの「What」、つまり骨組みをコードとして明示し、型推論の不安定性を完全に排除します。

2. **デザインルール（ノーマン原則、OOUIなど）**は、UIの「How」、つまり意味とふるまいの判断基準を提供し、実装品質を**195%向上**させます。

3. **目的・要件の明確化**は、UIの「Why」、つまり理由と優先順位を明確にし、ユーザー中心的な設計を実現します。

4. **WCAG 2.1準拠ガイドラインの提供**により、アクセシビリティ準拠率が**83%**に達し、包括的なUI設計が実現されます。

5. **設計情報の構造的提供**により、エージェントは単なるコード生成装置ではなく、設計意図を汲み取った賢明なUI実装パートナーとなります。

### 今後の展開

この検証結果を踏まえ、以下の領域での更なる研究と実践が期待されます：

1. **より複雑なUIパターンでの検証**
2. **他のリアクティブストア（Zustand、Jotai等）との比較**
3. **デザインシステムとの統合検証**
4. **パフォーマンス指標での定量評価**
5. **実際のプロダクト開発での長期検証**

設計情報は、エージェントにとって思考の素材であり、判断のフレームワークであり、対話のための共通言語です。適切な設計情報の提供により、コーディングエージェントは真のUI開発パートナーとして機能することが、この検証を通じて明確に実証されました。



